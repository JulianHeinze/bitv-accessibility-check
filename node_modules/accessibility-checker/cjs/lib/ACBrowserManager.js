"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ACBrowserManager = void 0;
const puppeteer = __importStar(require("puppeteer"));
const ACConfigManager_js_1 = require("./common/config/ACConfigManager.js");
class ACBrowserManager {
    static getBrowserChrome(force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!ACBrowserManager.config) {
                ACBrowserManager.config = yield ACConfigManager_js_1.ACConfigManager.getConfigUnsupported();
            }
            if (force || !ACBrowserManager.browserP) {
                let pupOptions = {
                    headless: ACBrowserManager.config.headless,
                    ignoreHTTPSErrors: ACBrowserManager.config.ignoreHTTPSErrors || false
                };
                if (ACBrowserManager.config.puppeteerArgs) {
                    pupOptions.args = ACBrowserManager.config.puppeteerArgs;
                }
                return ACBrowserManager.browserP = puppeteer.launch(pupOptions);
            }
            else {
                return ACBrowserManager.browserP;
            }
        });
    }
    static close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (ACBrowserManager.browserP) {
                let browser = yield ACBrowserManager.browserP;
                yield browser.close();
                ACBrowserManager.browserP = null;
                ACBrowserManager.pages = [];
            }
        });
    }
    /**
     * This function is responsible for building an iframe object with the provided URL or local file.
     *
     * @param {String} URLorLocalFile - Provide a URL or local file to scan.
     *
     * @return {Object} content - return an object which contains the iframeDoc and also the URL or
     *                               local file name.
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    static buildIframeAndGetDoc(URLorLocalFileorContent) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!ACBrowserManager.config) {
                ACBrowserManager.config = yield ACConfigManager_js_1.ACConfigManager.getConfigUnsupported();
            }
            const MAX_TABS = ACBrowserManager.config.maxTabs;
            const browser = yield ACBrowserManager.getBrowserChrome(false);
            // Clear out any pages that are already closed
            ACBrowserManager.pages = ACBrowserManager.pages.filter((page) => page && !page.isClosed());
            // If there's an existing, ready page, use it
            let availPage;
            for (const page of ACBrowserManager.pages) {
                if (!availPage) {
                    if (!page.aceBusy) {
                        availPage = page;
                        page.aceBusy = true;
                    }
                }
            }
            if (!availPage) {
                // All pages are busy. Should we create a new one?
                if (ACBrowserManager.pages.length + ACBrowserManager.numInits >= MAX_TABS) {
                    // Too many pages, restart
                    return new Promise((resolve, reject) => {
                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                            resolve(yield ACBrowserManager.buildIframeAndGetDoc(URLorLocalFileorContent));
                        }), 500);
                    });
                }
                else {
                    // Let's create a new page
                    ++ACBrowserManager.numInits;
                    let newPage = yield browser.newPage();
                    newPage.on('console', msg => {
                        for (let i = 0; i < msg.args.length; ++i)
                            console.log(`${i}: ${msg.args[i]}`);
                    });
                    newPage.aceBusy = true;
                    availPage = newPage;
                    ACBrowserManager.pages.push(newPage);
                    --ACBrowserManager.numInits;
                }
            }
            let err = null, retVal = null;
            function nav() {
                return __awaiter(this, void 0, void 0, function* () {
                    try {
                        if (URLorLocalFileorContent.toLowerCase().includes("<html")) {
                            // await page.goto(`data:text/html,encodeURIComponent(${URLorLocalFileorContent})`, { waitUntil: 'networkidle0' });
                            let urlStr = "data:text/html;charset=utf-8," + encodeURIComponent(URLorLocalFileorContent);
                            yield availPage.goto(urlStr);
                        }
                        else {
                            yield availPage.goto(URLorLocalFileorContent);
                        }
                    }
                    catch (e) {
                        err = `${e.message} ${URLorLocalFileorContent}`;
                        console.error(err);
                        return null;
                    }
                    return availPage;
                });
            }
            try {
                retVal = yield nav();
            }
            catch (e) {
            }
            if (!retVal) {
                // Page bad or unable to navigate, start over
                availPage.close();
                return new Promise((resolve, reject) => {
                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        resolve(yield ACBrowserManager.buildIframeAndGetDoc(URLorLocalFileorContent));
                    }), 0);
                });
            }
            if (retVal === null) {
                console.log("[Internal Error:load content]", err);
            }
            return retVal;
        });
    }
    ;
}
exports.ACBrowserManager = ACBrowserManager;
ACBrowserManager.pages = [];
//# sourceMappingURL=ACBrowserManager.js.map